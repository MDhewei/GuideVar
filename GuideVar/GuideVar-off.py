#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Modular prediction of off-target effects
@author: Wei He
@E-mail: whe3@mdanderson.org
@Date: 06/30/2021
"""

#################### Import all the packages #####################
from __future__ import division                
from itertools import product
from itertools import combinations
from scipy.stats import gmean
import pandas as pd
import math,json,os,pkg_resources  
import seaborn as sns
import numpy as np
import os,sys,re,argparse,logging
###################################################################

logging.basicConfig(level=logging.DEBUG,  
                    format='%(levelname)s:%(asctime)s @%(message)s',  
                    datefmt='%a, %d %b %Y %H:%M:%S',
                    filemode='a')

parser = argparse.ArgumentParser(description = 'Predict off-target effects of sgRNAs for Cas9 variants')
parser.add_argument('-i','--inputfile',type=str,help="MOFF aggregation can directly take the outputs of CRISPRitz or Cas-OFFinder as inputs. Besides, output table files generated by any other genome-wide off-target searching methods are supported in theory, but the columns of outputs for different methods are different, thus it is required to modify the column name of sgRNA(20bp+PAM) and target(20bp+PAM) to 'crRNA' and 'DNA' respectively. Note that only mismatch-only off-target predictions are supported, indel mutations are not applicable. File formats including .csv and .txt are accepted.",required=True)
parser.add_argument('-p','--prefix',type=str,help='Prefix of the file to save the outputs,default: GuideVarOff_Test',default='GuideVarOff_Test',required=False)
parser.add_argument('-o','--outputdir',type=str,help="Directory to save output files,if no directory is given a folder named\n GuideVar_scores will be generated in current working directory",default='GuideVar_scores',required=False)

args = parser.parse_args()



'''This function is to encode the sgRNA sequences into (16,19) vector with 0,1 presentation of 
   certain dinucleotide at certain position.
   o input:  sg_ls: A list of sgRNAs for one-hot encoding
             
   o Output: The function will return a numpy array of feature matrix for machine learning.
'''
def OneHotEndocing(sg_ls):
    di_ls = [s[0]+s[1] for s in list(product('ATGC', repeat=2))] ## Get all possible di-nucleotide combinations
    di_dic = {}
    for i in range(len(di_ls)): 
        di_dic[di_ls[i]] = i   ## Record the index of each dinucleotide

    ls_all = []   ## Initialize a list to add vector for different sgRNA
    for sg in sg_ls:
        vec_all = []
        for i in range(len(sg)-1):
            vec = [0]*len(di_ls) ## Make all position to be 0
            di = sg[i:i+2] 
            vec[di_dic[di]]=1  ## Assign 1 if certain dinucleotide appear at certain position
            vec_all.append(vec)
        
        ls_all.append(np.array(vec_all).T)
    
    return np.array(ls_all)


'''This function is obtain the mismatches between sgRNA and the target
   o input:  1). s1: the sequence of sgRNA; 2). s2: the sequence of target DNA
             
   o Output: The function will return: 1). A list of positions where mismatch happen. 
                                       2). A list of mismatch types at each position.
'''
def GetMutType(s1,s2):
    pos_ls = []; mut_ls = []
    for i in range(20): ## Go through the index along the 20bp sequence
        r = ''; d = ''
        if s1[i]!=s2[i]:
            pos = 20-i ## The index relative to PAM
            if s1[i] == 'T': r = 'U' ## Replace 'T' with 'U' in sgRNA.
            else: r = s1[i]
            ## Get mutation type given the nt at sgRNA and target
            if s2[i] == 'A': d='T' 
            elif s2[i] == 'T': d='A'
            elif s2[i] == 'C': d = 'G'
            elif s2[i] == 'G': d = 'C'
            elif s2[i] == 'N': d = s1[i]
            pos_ls.append(pos)
            mut_ls.append('p'+str(pos)+'r'+r+'d'+d) ## p3rAdC: mismatch A-G at index 3 to PAM
    return pos_ls,mut_ls


'''This function is Calculate the off-target effect by multiplying the MDE at each position
   o input:1). m1_dic: Python dic contains MDE of all the possible nucleotide mismatches (12) 
               at all possible positions (20) 
           2). sg_ls: A list of sgRNAs
           3). tg_ls: A list of DNA targets
             
   o Output: A list of calculated mismatch-dependent effect.
'''
def Multiply(m1_dic,sg_ls,tg_ls):
    me_ls = []
    for i in range(len(sg_ls)):
        s1 = sg_ls[i][0:20].upper()
        s2 = tg_ls[i][0:20].upper()
        #print (s1,s2)
        mut_ls = GetMutType(s1,s2)[1]
        score = 1
        for mut in mut_ls:  ##Multiply all the 1-mismatch effects
            score = score*m1_dic[mut] ##m1_dic: dic file 
        me_ls.append(score)
        
    return me_ls


'''This function is to get mismatch numbers of gRNA-target pairs'''

def MisNum(sg_ls,tg_ls):
    num_ls = []
    for i in range(len(sg_ls)):
        s1 = sg_ls[i][0:20].upper()
        s2 = tg_ls[i][0:20].upper()
        
        num = len(GetMutType(s1,s2)[0])
        num_ls.append(num)
        
    return num_ls


def MisType(sg_ls,tg_ls):
    tp_ls = []
    for i in range(len(sg_ls)):
        s1 = sg_ls[i][0:20].upper()
        s2 = tg_ls[i][0:20].upper()
        
        tp = '|'.join(GetMutType(s1,s2)[1])
        tp_ls.append(tp)
        
    return tp_ls


'''This function is Calculate Combinatorial effect (CE) for given mismatch positions
   o input:1). m2_dic: Python dic contains CE of all the possible position combinaitons
           2). sg_ls: A list of sgRNAs
           3). tg_ls: A list of DNA targets
           
   o Output: A list of calculated combinatorial effects.
'''
def CombineGM(m2_dic,sg_ls,tg_ls):
    cm_ls = []
    for i in range(len(sg_ls)):
        s1 = sg_ls[i][0:20].upper()
        s2 = tg_ls[i][0:20].upper()
        pos_ls = sorted(GetMutType(s1,s2)[0])
        
        ## Combinatorial effect at certain position combination.
        di_ls = list(combinations(pos_ls,2))
        c_ls = [m2_dic[str(di[0])+'&'+str(di[1])] for di in di_ls] 
        
        if len(pos_ls) > 1:
            m = gmean(c_ls)**(len(pos_ls)-1) ## Geometirc mean of all possible combinations
        else:
            m = 1
        cm_ls.append(m)
    return cm_ls


'''This function is predict off-target MOFF score for given gRNA-target pairs
   o input:1). m2_dic: Python dic contains CE of all the possible position combinaitons (20*19)
           2). m1_dic: Python dic contains MDE of all the possible nucleotide mismatches (12) 
               at all possible positions (20)  
           3). df: A panda dataframe with one column of sgRNA and another column of DNA targets
           
   o Output: A panda dataframe with off-target predictions using different models (factors) 
'''
def MOFF_score(m1_dic,m2_dic,df):
    from keras import models
    from keras import layers
    from keras import optimizers
    
    sg_ls = list(df['crRNA']) # Get list of input sgRNAs
    tg_ls = list(df['DNA']) # Get list of input DNA targets
    
    np.random.seed(24) # for reproducibility
    model = models.load_model('/GuideVar/models/GOP_model_3.h5')
    pred_test = list(model.predict(OneHotEndocing([s.upper()[0:20] for s in sg_ls])))
    df['GOP'] = [g[0] for g in pred_test]
    
    
    df['MDE'] = Multiply(m1_dic,sg_ls,tg_ls)
    df['CE'] = CombineGM(m2_dic,sg_ls,tg_ls)
    df['MMs'] = MisNum(sg_ls,tg_ls)
    df['MisType'] = MisType(sg_ls,tg_ls)
    df['GMT'] = df['GOP']**df['MMs']
    df['GuideVar.Off'] = df['MDE']*df['CE']*df['GMT']
    return df


'''This function is predict GuideVar-off score for given gRNA-target pairs
   o input:1). m2_dic: Python dic contains CE of all the possible position combinaitons (20*19)
           2). m1_dic: Python dic contains MDE of all the possible nucleotide mismatches (12) 
               at all possible positions (20)  
           3). df: A panda dataframe with one column of sgRNA and another column of DNA targets
           
   o Output: A panda dataframe with aggregated off-target scores for each sgRNAs using different models (factors) 
'''
def MOFF_aggregate(m1_dic,m2_dic,df):
    df_score = MOFF_score(m1_dic,m2_dic,df)
    sg_ls = []; gmt_ls = []; mde_ls = []; moff_ls = []
    for sg in set(df['crRNA']):  ## Go through all the sgRNAs 
        df_sg = df_score[df_score['crRNA']==sg] ## Get all the off-targets for certain sgRNA
        sg_ls.append(sg)
        gmt_ls.append(df_sg['GOP'].mean())
        ##### Sum up the scores for single gRNA-target pairs ####
        
        if list(df_sg['MMs']).count(0) >=1:
            mde_ls.append(np.log(df_sg['MDE'].sum()-1))
            moff_ls.append(np.log(df_sg['GuideVar.Off'].sum()-1))
        else:
            mde_ls.append(np.log(df_sg['MDE'].sum()))
            moff_ls.append(np.log(df_sg['GuideVar.Off'].sum()))
    
    df_out = pd.DataFrame({'sgRNA':sg_ls,'GMT':gmt_ls,'GuideVarOff.Sum':moff_ls})
    return df_score,df_out



m1_dic = json.loads(open('/GuideVar/models/M1_dic_variants').read())
m2_dic = json.loads(open('/GuideVar/models/M2_matrix_smooth_MLE').read())

Inputfile =  args.inputfile
try:
    os.mkdir(args.outputdir)
    logging.info('Creat the outputdir {} to place result files'.format(args.outputdir))
except OSError:
    logging.warning('outputdir {} already exist'.format(args.outputdir))

outputdir = os.path.join(os.getcwd(),args.outputdir) ## Set the path to outputdir
prefix = args.prefix

                                 
with open(Inputfile,'r') as f:
    firstline = f.readline()
    if 'crRNA' not in firstline or 'DNA' not in firstline:
        logging.error('!!! Input table should contain columns with name: crRNA \
                        and DNA to present sgRNA sequences and off-target sequences')
        sys.exit(-1)
        
logging.info("Reading the input genome-wide off-targets table...")                         
if '.txt' in Inputfile:
    df_in = pd.read_csv(Inputfile, delimiter="\t")
elif '.csv' in Inputfile:
    df_in = pd.read_csv(Inputfile)
else:
    logging.error('Oops! Something wrong with the input file formats, accepted files includes .csv and .txt are accepted, please provide correct file format.')
    sys.exit(-1)
        
print(df_in)
df_score,df_out = MOFF_aggregate(m1_dic,m2_dic,df_in)
df_score.to_csv(os.path.join(outputdir,prefix+'_GuideVarOff.score.csv'))
df_out.to_csv(os.path.join(outputdir,prefix+'_GuideVarOff.aggregate.csv'))
logging.info('^o^ Great! Job finished and results successfully saved, Check it in the output folder! Bye!')
